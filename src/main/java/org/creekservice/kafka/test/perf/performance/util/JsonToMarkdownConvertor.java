/*
 * Copyright 2023 Creek Contributors (https://github.com/creek-service)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.creekservice.kafka.test.perf.performance.util;

import static java.lang.System.lineSeparator;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Objects.requireNonNull;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.creekservice.kafka.test.perf.performance.util.model.PerformanceResult;

public final class JsonToMarkdownConvertor {

    private static final List<String> HEADINGS =
            List.of("Benchmark", "Mode", "Score", "Score Error (99.9%)", "Unit");

    private final PerformanceJsonReader reader;

    public JsonToMarkdownConvertor() {
        this(new PerformanceJsonReader());
    }

    JsonToMarkdownConvertor(final PerformanceJsonReader reader) {
        this.reader = requireNonNull(reader, "reader");
    }

    /**
     * Convert a JSON performance result file into markdown.
     *
     * @param jsonResult the JSON performance result data to read. Generated by JMH.
     * @param reportRoot the directory markdown performance results should be written to.
     */
    public void convert(final Path jsonResult, final Path reportRoot) {
        writeMarkdown(convert(jsonResult), reportRoot);
    }

    Map<String, String> convert(final Path jsonResult) {
        final Map<String, List<PerformanceResult>> splitResults =
                splitResults(reader.read(jsonResult));
        return splitResults.entrySet().stream()
                .collect(Collectors.toMap(Map.Entry::getKey, e -> convert(e.getValue())));
    }

    private static String convert(final List<PerformanceResult> results) {
        final StringBuilder builder = new StringBuilder();
        builder.append(headings());
        results.forEach(result -> builder.append(row(result)));
        return builder.toString();
    }

    private static Map<String, List<PerformanceResult>> splitResults(
            final PerformanceResult[] results) {
        return Arrays.stream(results).collect(Collectors.groupingBy(result -> result.testClass()));
    }

    private static void writeMarkdown(final Map<String, String> converted, final Path reportRoot) {
        converted.forEach(
                (testName, reportContent) ->
                        writeMarkdown(reportContent, reportRoot.resolve(testName + ".md")));
    }

    private static void writeMarkdown(final String markdown, final Path file) {
        try {
            Files.write(file, markdown.getBytes(UTF_8));
        } catch (IOException e) {
            throw new RuntimeException("Failed to write to " + file, e);
        }
    }

    private static String headings() {
        final String headings = HEADINGS.stream().collect(Collectors.joining(" | ", "| ", " |"));
        final String nextLine =
                HEADINGS.stream()
                        .map(heading -> "-".repeat(heading.length()))
                        .collect(Collectors.joining("-|-", "|-", "-|"));
        return headings + lineSeparator() + nextLine + lineSeparator();
    }

    private static String row(final PerformanceResult result) {
        final List<String> values =
                List.of(
                        result.testCase(),
                        result.mode(),
                        formatDecimal(result.metric().score()),
                        result.metric()
                                .scoreError()
                                .map(JsonToMarkdownConvertor::formatDecimal)
                                .orElse(""),
                        result.metric().scoreUnit());
        final String row = values.stream().collect(Collectors.joining(" | ", "| ", " |"));
        return row + lineSeparator();
    }

    private static String formatDecimal(final BigDecimal decimal) {
        final int sigFig = 5;
        final int exponent = decimal.precision() - decimal.scale();
        final int scale = Math.max(0, sigFig - exponent);
        final BigDecimal scaledNumber = decimal.setScale(scale, RoundingMode.HALF_EVEN);
        return scaledNumber.toPlainString();
    }
}
